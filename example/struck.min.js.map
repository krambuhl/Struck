{"version":3,"file":"struck.min.js","sources":["_export.js","utilities.js","hook.js","computed.js","extend.js","base-object.js","event-object.js","intercom.js","model.js","view.js","_after.js"],"names":[],"mappings":"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","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['lodash', 'jquery', 'exports'], function(_, $, exports) {\n      root.Struck = factory(root, exports, _, $);\n    });\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('lodash'), $ = require('jquery');\n    exports = factory(root, exports, _, $);\n  } else {\n    root.Struck = factory(root, {}, root._, root.jQuery);\n  }\n}(this, function(root, Struck, _, $, undefined) {\n","function capitalize(string) {\n\treturn string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n// #####splitName\n// split \"event1 event2\" into an\n// array of event names\nfunction splitName(name, context) {\n\tif (_.isUndefined(context)) context = this;\n\t// get result of name if defined as a function\n\tvar result = _.isFunction(name) ? name.call(context) : name;\n\n\t// split by spaces if result isn't an array\n\t// always returns an array\n\treturn _.isArray(result) ? result : result.split(\" \");\n}\n\n// #####result\n// returns get result of an expression\nfunction result(expr) {\n\treturn _.isFunction(expr) ? expr() : expr;\n}","// ##Hook\n\n// wraps function calls with hook logic,\n// used to wrap method calls in an Struck\n// Object.  The object's hook function will be\n// called before and after the function call\n// by default \n\n// __Example:__\n// ```javascript\n// var HookedObj = Struck.EventObject.extend({\n//   initialize: function () {\n//\n//     this.com.on('beforeSayHello', function() {\n//       console.log('open mouth');\n//     });\n//   },\n//\n//   sayHello: Struck.Hook(function () {\n//     console.log('say hello');\n//   })\n// })\n//\n// var myHookedObject = HookedObj.create({\n//   onSayHello: function() {\n///    console.log('hello complete);\n//   },\n//   afterSayHello: function () {\n//     console.log('close mouth');\n//   }\n// });\n//\n// myHookedObject.sayHello();\n//\n// output:\n//   - open mouth\n//   - say hello\n//   - hello complete\n//   - close mouth\n// ```\n\nStruck.Hook = function () {\n  var defaults = {\n    prefix: 'on',\n    pre: 'before',\n    post: 'after',\n    method: 'hook'\n  };\n\n  function fire(self, method, hname, prefix) {\n    if (self[method]) {\n      self[method].call(self, hname, prefix);\n    }\n  }\n\n  function Hook(name, func, opts) {\n    var options = _.extend({}, defaults, !_.isFunction(func) ? func : opts);\n\n    // define function to called as a method of\n    // Struck Object, the `this` context is assumed\n    // to refer to the struck object.\n    return function() {\n      var result;\n\n      if (options.pre) {\n        fire(this, options.method, name, options.pre);\n      }\n\n      if (_.isFunction(func)) {\n        result = func.apply(this, arguments);\n      }\n\n      fire(this, options.method, name, options.prefix);\n\n      if (options.post) {\n        _.defer(fire, this, options.method, name, options.post);\n      }\n\n      return result;\n    };\n  }\n\n  return Hook;\n}();\n","Struck.Computed = function () {\n  var defaults = {};\n\n  function Computed() {\n    var options = _.extend({}, defaults, opts);\n    options = options;\n  }\n\n  return Computed;\n}();\n\n\n// var example = Struck.BaseObject.create();\n// example.set({\n//   title: 'Hello World',\n//   slug: Struck.Computed('title', function() {\n//   \treturn this.get('title')\n//   \t\t.toLowerCase()\n//   \t\t.split(' ')\n//   \t\t.join('-');\n//   })\n// });\n\n// var example = Struck.BaseObject.create();\n// example.set({\n//   make: 'Volvo',\n//   model: 'Amazon',\n//   slug: Struck.Computed('make', 'model', function() {\n//   \treturn [this.get('make'), this.get('model')].join('-').toLowerCase();\n//   })\n// });\n\n// var example = Struck.BaseObject.create();\n// example.set({\n//   make: 'Suburu',\n//   model: 'Forester',\n//   slug: Struck.Computed(['make', 'model'], function() {\n//   \treturn [this.get('make'), this.get('model')].join('-').toLowerCase();\n//   })\n// });","// ###Extend\n\n// _Pulled from Backbone.js 1.1.2 source_\n//\n// Helper function to correctly set up the prototype chain,\n// for subclasses. Similar to goog.inherits, but uses a hash\n// of prototype properties and class properties to be extended.\n\nStruck.extend = function(protoProps, staticProps) {\n  var parent = this;\n  var child;\n\n  // The constructor function for the new subclass is either defined\n  // by you (the “constructor” property in your extend definition),\n  // or defaulted by us to simply call the parent’s constructor.\n  if (protoProps && _.has(protoProps, 'constructor')) {\n    child = protoProps.constructor;\n  } else {\n    child = function() { return parent.apply(this, arguments); };\n  }\n\n  // Add static properties to the constructor function, if supplied.\n  _.extend(child, parent, staticProps);\n\n  // Set the prototype chain to inherit from parent,\n  // without calling parent‘s constructor function.\n  var Surrogate = function() { this.constructor = child; };\n  Surrogate.prototype = parent.prototype;\n  child.prototype = new Surrogate;\n\n  // Add prototype properties (instance properties)\n  // to the subclass, if supplied.\n  if (protoProps) _.extend(child.prototype, protoProps);\n\n  // Set a convenience property in case the\n  // parent’s prototype is needed later.\n  child.__super__ = parent.prototype;\n\n  return child;\n};\n","// ##BaseObject\n\n// function for enabling common architectures\nStruck.BaseObject = function () {\n\n\t// ####BaseObject Constructor\n\n\t// constructor is run when object is created\n\t// runs base initiation by default\n\n\t// __Warning: overwriting the BaseObject\n\t// Constructor will disable internal processes.__\n\t// In cases where overwriting the constructor\n\t// is required call the prototype to preserve\n\t// functionality:\n\n\t// `Struck.BaseObject.prototype.constructor.apply(this, arguments);`\n\n\tfunction BaseObject(options) {\n\t\t// run base initiation and provide\n\t\t// hooks that extended objects can use\n\t\tthis.baseInitiation(options);\n\t\tthis.initialize();\n\t}\n\n\t// #####initialize\n\t// overwritable function that gets called\n\t// when constructing new objects\n\tBaseObject.prototype.initialize = _.noop;\n\n\n\t// #####baseInitiation\n\t// when the object is created\n\tBaseObject.prototype.baseInitiation = Struck.Hook('baseInitiation', function(options) {\n\t\t// assign UID to view object\n\t\tthis.uid = _.uniqueId('struck');\n\n\t\t// add options object to instance\n\t\tthis.options = _.extend({}, options);\n\t});\n\n\t// #####hook\n\t// interface for providing method callbacks\n\t// like `onRender`\n\tBaseObject.prototype.hook = function(name, mod) {\n\t\tvar args = _.rest(arguments, 2),\n\t\t\tprefix = mod || 'on',\n\t\t\tmethodHook = prefix + capitalize(name);\n\n\t\tif (this[methodHook]) {\n\t\t\treturn this[methodHook].apply(this, args);\n\t\t}\n\t};\n\n\tfunction reduceProps(self, props) {\n\t\treturn _.reduce(props, function(memo, prop) {\n\t\t\tmemo[prop] = self.get(prop);\n\t\t\treturn memo;\n\t\t}, {});\n\t}\n\n\t// #####get\n\tBaseObject.prototype.get = Struck.Hook('get', function(prop) {\n\t\tvar args = _.toArray(arguments);\n\t\tif (_.isArray(prop)) {\n\t\t\treturn reduceProps(this, prop);\n\t\t} else if (args.length > 1) {\n\t\t\treturn reduceProps(this, args);\n\t\t}\n\t\treturn this[prop];\n\t});\n\n\t// #####set\n\tBaseObject.prototype.set = Struck.Hook('set', function(prop, val) {\n\t\tprop = result(prop);\n\t\tif (_.isObject(prop)) {\n\t\t\t_.each(prop, function(value, property) {\n\t\t\t\tthis.set(property, value);\n\t\t\t}, this);\n\t\t}\n\t\tthis[prop] = result(val);\n\t});\n\n\tBaseObject.extend = Struck.extend;\n\n\t// ###create\n\t// prefered method of creating new objects\n\t// over using the `new` style\n\tBaseObject.create = function(props, opts) {\n\t\tvar object = this.extend(props);\n\t\treturn new object(_.extend({}, props, opts));\n\t};\n\n\treturn BaseObject;\n}();\n","// ##EventObject\n\n// `Struck.EventObject` normalizes an event API\n// for adding event listeners and listening to\n// objects externally.  Using the listen methods\n// automates undelgating events of view removal.\nStruck.EventObject = function () {\n\n\n\tvar EventObject = Struck.BaseObject.extend({\n\t\tbaseInitiation: function () {\n\t\t\t// all event objects need an intercom for\n\t\t\t// emiting and listening to events\n\t\t\tthis.com = new Struck.Intercom();\n\n\t\t\t// call super after defining com which\n\t\t\t// is used for base hooks\n\t\t\tStruck.BaseObject.prototype.baseInitiation.apply(this, arguments);\n\n\t\t\tthis._events = [];\n\t\t}\n\t});\n\n\t// #####hook\n\n\t// trigger intercom events for hook\n\tEventObject.prototype.hook = function (name, mod) {\n\t\tvar postfix = mod !== undefined ? ':' + mod : '';\n\t\tStruck.BaseObject.prototype.hook.apply(this, arguments);\n\t\tthis.com.emit(name + postfix, arguments);\n\t};\n\n\tfunction addListener(obj, events, func, opts) {\n\t\tthis._events.push({\n\t\t\tevents: events,\n\t\t\tfunc: func,\n\t\t\tobj: obj\n\t\t});\n\n\t\tvar wrap = func;\n\t\tif (opts.once) {\n\t\t\twrap = function () {\n\t\t\t\tfunc.apply(obj);\n\t\t\t\tremoveListener(obj, events, func, opts);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction removeListener(obj, events, func, opts) {\n\t\t_.reject(this._events, {\n\t\t\tevents: events,\n\t\t\tfunc: func,\n\t\t\tobj: obj\n\t\t});\n\n\t}\n\n\t// #####listenTo\n\n\t// Registers a event listener to the\n\t// appropriate subsystem. Delegates jquery\n\t// objects to the jq event system and struk\n\t// objects to the instance's intercom\n\t// we then keep a secondary object of events\n\t// to remove when the object is deconstructed\n\tEventObject.prototype.listenTo = function (obj, events, func) {\n\t\t// if object is jquery wrapped\n\t\t// delegate events into object\n\n\t\t// if object is Struck.EventObject\n\t\t// delegate events to the underlying\n\t\t// com object\n\n\t\tif (obj instanceof jQuery) {\n\t\t\t// do jquery stuff\n\n\t\t// if object is (or extended from) an event object\n\t\t// we can assume it has an Intercom\n\t\t} else if (obj instanceof Struck.EventObject) {\n\t\t\taddListener(obj, events, func);\n\t\t}\n\t};\n\n\t// #####listenOnce\n\tEventObject.prototype.listenOnce = function (obj, events, func) {\n\n\t};\n\n\t// #####stopListening\n\t// removes an event listener from the\n\t// appropriate subsystem.\n\t// typeof obj == jquery ? jquery.off\n\t// typeof ogj == Struck.EventObjt ? com.off\n\tEventObject.prototype.stopListening = function (obj, events, func) {\n\n\t};\n\n\t// #####stopListeningAll\n\t// remove all event listeners from Object\n\t// iterates over internal list, delegating\n\t// to stopListening\n\tEventObject.prototype.stopListeningAll = function (obj, events, func) {\n\n\t};\n\n\t// #####destroy\n\t// when an object is removed, the destroy function\n\t// should be called to remove attached event listeners\n\tEventObject.prototype.destroy = Struck.Hook('destroy', function () {\n\t\t// remove all event listeners listeners\n\t\tthis.stopListeningAll();\n\t});\n\n\n\treturn EventObject;\n}();\n","// ##Intercom\n\n// A standalone function for an event subscriber\n// system to be used in other modules\nStruck.Intercom = function (root) {\n\t// setup default subscription object\n\t// used to clone and extend in `subscribe` function\n\tvar defaultSubscription = {\n\t\tsingle: false,\n\t\tname: \"all\",\n\t\tcallback: _.noop,\n\t\tcontext: root,\n\t\targs: []\n\t};\n\n\t// get keys from default subscription object\n\t// useful for iteration and filtering\n\tvar subscriptionKeys = _.keys(defaultSubscription);\n\n\t// #####Constructor\n\t// set up default subscriptio object's context to the\n\t// intercom instance and create subscription collection\n\tvar Intercom = Struck.BaseObject.extend({\n\t\tbaseInitiation: function () {\n\t\t\tStruck.BaseObject.prototype.baseInitiation.apply(this, arguments);\n\t\t\tthis.defaultSubscription = _.extend(_.clone(defaultSubscription), { context: this });\n\t\t\tthis.subscriptions = [];\n\t\t}\n\t});\n\n\n\n\n\t// #####splitName\n\t// split \"event1 event2\" into an\n\t// array of event names\n\tfunction splitName(com, name) {\n\t\t// get result of name if defined as a function\n\t\tvar result = _.isFunction(name) ? name.call(com) : name;\n\n\t\t// split by spaces if result isn't an array\n\t\t// always returns an array\n\t\treturn _.isArray(result) ? result : result.split(\" \");\n\t}\n\n\t// #####subscribe\n\t// build subscription object from\n\t// name and function, additional\n\t// options are optional...\n\tfunction subscribe(com, name, func, options) {\n\t\tif (!name && !func) return;\n\n\t\tvar subOptions = {\n\t\t\tname: name,\n\t\t\tcallback: func\n\t\t};\n\n\t\t// add useful options to subOptions\n\t\t_.each(subscriptionKeys, function (key) {\n\t\t\tif (options[key]) subOptions[key] = options[key];\n\t\t});\n\n\t\t// create a new subscription from the default object\n\t\t// and overwrite properties with subOptions,\n\t\t// then adds subscription to collection\n\t\tvar subscription = _.extend(_.clone(defaultSubscription), subOptions);\n\n\t\tcom.subscriptions.push(subscription);\n\t}\n\n\t// #####unsubscribe\n\t//\n\tfunction unsubscribe(com, name, func) {\n\t\tvar filter = function (sub) {\n\t\t\t// com, name, func:\n\t\t\t// .. remove specific subscriber function\n\t\t\tif (func) {\n\t\t\t\treturn sub.name == name && sub.callback == func;\n\n\t\t\t// com, name:\n\t\t\t// .. remove all subscribers by name\n\t\t\t} else if (name) {\n\t\t\t\treturn sub.name == name;\n\t\t\t}\n\n\t\t\t// remove all subscriptions if no arguments provided\n\t\t\treturn true;\n\t\t};\n\n\t\tcom.subscriptions = _.reject(com.subscriptions, filter);\n\t}\n\n\t// #####trigger\n\t//\n\tfunction trigger(com, sub, data) {\n\t\tsub.callback.apply(sub.context, data ? [data].concat(sub.args) : sub.args);\n\t}\n\n\t// #####Intercom.on\n\tIntercom.prototype.on = function(names, callback, context) {\n\t\tvar args = _.rest(arguments, 3);\n\t\t_.each(splitName(this, names), function (name) {\n\t\t\tsubscribe(this, name, callback, {\n\t\t\t\tsingle: false,\n\t\t\t\tcontext: context,\n\t\t\t\targs: args\n\t\t\t});\n\t\t}, this);\n\t};\n\n\t// #####Intercom.once\n\tIntercom.prototype.once = function(names, callback, context) {\n\t\tvar args = _.rest(arguments, 3);\n\t\t_.each(splitName(this, names), function (name) {\n\t\t\tsubscribe(this, name, callback, {\n\t\t\t\tsingle: true,\n\t\t\t\tcontext: context,\n\t\t\t\targs: args\n\t\t\t});\n\t\t}, this);\n\t};\n\n\t// #####Intercom.off\n\tIntercom.prototype.off = function(names, callback) {\n\t\tif (names === undefined || names === \"all\") {\n\t\t\tunsubscribe(this);\n\t\t\treturn;\n\t\t}\n\n\t\t_.each(splitName(this, names), function (name) {\n\t\t\tunsubscribe(this, name, callback);\n\t\t}, this);\n\t};\n\n\t// #####Intercom.emit\n\tIntercom.prototype.emit = function (names, data) {\n\t\tvar filteredSubs = _.reduce(splitName(this, names), function (subs, name) {\n\t\t\tvar matches = _.filter(this.subscriptions, function (subscriber) {\n\t\t\t\treturn subscriber.name == name;\n\t\t\t}, this);\n\n\t\t\treturn subs.concat(matches);\n\t\t}, [], this);\n\n\t\tfilteredSubs = _.unique(filteredSubs);\n\n\t\t_.each(filteredSubs, function(sub) {\n\t\t\ttrigger(this, sub, data);\n\t\t}, this);\n\t};\n\n\treturn Intercom;\n}(root);\n","// ##Model\n\n// object for maintaining data\nStruck.Model = function () {\n\tvar Model = Struck.EventObject.extend({\n\t\tbaseInitiation: function(options) {\n\t\t\tStruck.EventObject.prototype.baseInitiation.apply(this, arguments);\n\t\t\t\n\t\t\tthis.data = this.options.data || {};\n\t\t}\n\t});\n\n\tModel.prototype.get = Struck.Hook(\"get\", function(prop) {\n\t\treturn this.data[prop];\n\t});\n\t\n\tModel.prototype.set = Struck.Hook(\"set\", function(prop, val) {\n\t\t// if the first arg is an object\n\t\t// update multiple properties\n\t\tif (_.isObject(prop)) {\n\t\t\t_.extend(this.data, prop);\n\t\t} else {\n\t\t\tthis.data[prop] = val;\n\t\t}\n\t});\n\t\n\n\treturn Model;\n}();\n","// ##View\n\n// Defines a base view to be extend\nStruck.View = function () {\n  // array of options that will be extended\n  // to the view when initialized\n  var viewOptions = ['el', 'ui', 'template', 'model'];\n\n  // `View` constructor returns a View object\n  // that contains methods for template/model\n  // rendering, dom caching, and event listening.\n  var View = Struck.EventObject.extend();\n\n  View.prototype.baseInitiation = function () {\n    Struck.EventObject.prototype.baseInitiation.apply(this, arguments);\n\n    var self = this;\n    // extend selected instance opitions to object\n    _.extend(this, _.pick(this.options, viewOptions));\n\n    // gets model\n    this.model = _.result(self, 'model');\n\n    // setup view elements\n    if (this.el) this.setElement(_.result(this, 'el'));\n\n    // render template with model if defined\n    if (this.template) this.render();\n\n    _.defer(function () {\n      // cache jquery elements\n      setupUI(self, _.result(self, 'ui'));\n\n      // run setup function\n      self.setup(self.options);\n    });\n  };\n\n  // caches the dom object and creates scoped find function\n  View.prototype.setElement = function(el) {\n    this.$el = $(el).eq(0);\n    this.el = this.$el[0];\n    this.$ = function(el) { return this.$el.find(el); };\n  };\n\n  // `render` function that runs\n  // template function with model data\n  View.prototype.render = _.noop;\n\n  // overwritable `setup` function\n  // called when View is initialized\n  View.prototype.setup = _.noop\n\n  // overwritable `cleanup` function\n  // that should be called when removing\n  // a view to remove event listeners\n  // or any possible memory leaks\n  View.prototype.cleaup = _.noop;\n\n  View.prototype.listenTo = function () { };\n\n  // ###Private Functions\n\n  // cache dom objects from UI object\n  function setupUI(view, ui) {\n    view.ui = _.reduce(ui, function (result, selector, name) {\n      result[name] = view.$(ui[name]);\n      return result;\n    }, {});\n    \n    // a ui object of:\n    // `{ header: '.header' }`\n    // results with an object like:\n    // `view.ui = {\n    //    header: $('.header')  \n    // }`\n    // then\n    // `view.ui.header.on('click', func)`\n  }\n\n  return View;\n}();\n","\treturn Struck;\n}));\n"],"sourceRoot":"/source/"}